import { NextRequest, NextResponse } from 'next/server'
import { retryWithKeyRotation } from '@/lib/api-keys/retry-with-fallback'

const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent'

interface Flashcard {
  front: string
  back: string
  category: string
}

interface FlashcardRequest {
  content: string
  cardCount?: number
  difficulty?: 'bachelor' | 'master' | 'phd'
}

interface FlashcardResponse {
  success: boolean
  flashcards?: Flashcard[]
  error?: string
  details?: string[]
}

export async function POST(request: NextRequest) {
  try {
    const body: FlashcardRequest = await request.json()
    const { content, cardCount = 10, difficulty = 'bachelor' } = body

    if (!content || content.trim().length === 0) {
      return NextResponse.json<FlashcardResponse>(
        {
          success: false,
          error: 'Content is required',
          details: ['Please provide lecture content to generate flashcards from'],
        },
        { status: 400 }
      )
    }

    const prompt = `Based on the following lecture content, generate ${cardCount} educational flashcards at a ${difficulty} level.

Format your response as a JSON array where each flashcard has this structure:
{
  "front": "Question or concept prompt",
  "back": "Answer or explanation",
  "category": "Topic category from the lecture"
}

Guidelines:
- Create flashcards that help with active recall and understanding
- Difficulty level: ${difficulty} (bachelor = undergraduate level, master = graduate level, phd = advanced research level)
- Front: Should be a clear question, definition prompt, or key concept
- Back: Should provide a concise, accurate answer or explanation
- Category: Identify which main topic from the lecture this flashcard belongs to
- Focus on the most important concepts, definitions, and relationships
- Make questions specific and answerable
- Adjust complexity and depth based on the ${difficulty} level
- Include a mix of definitional, conceptual, and application-based flashcards

Lecture Content:
${content.substring(0, 10000)}

Respond with ONLY the JSON array, no other text.`

    // Call Gemini API with automatic retry and key rotation
    const result = await retryWithKeyRotation(
      async (apiKey: string) => {
        const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }],
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: 3048,
            },
          }),
        })

        if (!response.ok) {
          const errorText = await response.text()
          const error: any = new Error(`HTTP ${response.status}: ${response.statusText}`)
          error.responseText = errorText
          throw error
        }

        return response.json()
      },
      {
        maxRetries: 5,
        onRetry: (attempt, error) => {
          console.log(`[Flashcards] Retry attempt ${attempt} due to: ${error.message}`)
        }
      }
    )

    if (!result.candidates || result.candidates.length === 0) {
      throw new Error('No flashcards generated by Gemini API')
    }

    const generatedText = result.candidates[0].content.parts[0].text

    // Parse JSON from the response
    let flashcards: Flashcard[]
    try {
      // Extract JSON array from response (handle markdown code blocks)
      const jsonMatch = generatedText.match(/\[[\s\S]*\]/)
      if (!jsonMatch) {
        throw new Error('No JSON array found in response')
      }
      flashcards = JSON.parse(jsonMatch[0])
    } catch (parseError) {
      console.error('Failed to parse flashcards JSON:', parseError)
      return NextResponse.json<FlashcardResponse>(
        {
          success: false,
          error: 'Failed to parse generated flashcards',
          details: ['The AI response was not in the expected format'],
        },
        { status: 500 }
      )
    }

    // Validate flashcards structure
    if (!Array.isArray(flashcards) || flashcards.length === 0) {
      return NextResponse.json<FlashcardResponse>(
        {
          success: false,
          error: 'Invalid flashcards format',
          details: ['Generated flashcards were empty or malformed'],
        },
        { status: 500 }
      )
    }

    return NextResponse.json<FlashcardResponse>(
      {
        success: true,
        flashcards,
      },
      { status: 200 }
    )
  } catch (error: any) {
    console.error('[Flashcards] Generation error after retries:', error)

    // Handle retry exhaustion gracefully
    if (error.exhaustedKeys) {
      return NextResponse.json<FlashcardResponse>(
        {
          success: false,
          error: 'AI service temporarily unavailable',
          details: ['All available API keys are currently exhausted. Please try again in a few moments.'],
        },
        { status: 503 }
      )
    }

    return NextResponse.json<FlashcardResponse>(
      {
        success: false,
        error: 'Internal server error',
        details: [error.message || 'An unexpected error occurred'],
      },
      { status: 500 }
    )
  }
}
