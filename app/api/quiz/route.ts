import type { NextRequest } from 'next/server'
import { NextResponse } from 'next/server'
import { retryWithKeyRotation } from '@/lib/api-keys/retry-with-fallback'
import { logger } from '@/lib/utils/logger'

const GEMINI_API_URL =
  'https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent'

interface QuizQuestion {
  question: string
  options: string[]
  correctAnswer: number
  explanation: string
}

interface QuizRequest {
  content: string
  questionCount?: number
  difficulty?: 'bachelor' | 'master' | 'phd'
}

interface QuizResponse {
  success: boolean
  quiz?: {
    questions: QuizQuestion[]
    totalQuestions: number
    difficulty: string
  }
  error?: string
  details?: string[]
}

export async function POST(request: NextRequest) {
  try {
    const body: QuizRequest = await request.json()
    const { content, questionCount = 5, difficulty = 'bachelor' } = body

    if (!content || content.trim().length === 0) {
      return NextResponse.json<QuizResponse>(
        {
          success: false,
          error: 'Content is required',
          details: ['Please provide lecture content to generate quiz from']
        },
        { status: 400 }
      )
    }

    const prompt = `Based on the following lecture content, generate ${questionCount} multiple-choice questions at a ${difficulty} level.

Format your response as a JSON array where each question has this structure:
{
  "question": "The question text",
  "options": ["Option A", "Option B", "Option C", "Option D"],
  "correctAnswer": 0,
  "explanation": "Why this answer is correct"
}

Guidelines:
- Questions should test understanding of key concepts
- Difficulty level: ${difficulty} (bachelor = undergraduate level, master = graduate level, phd = advanced research level)
- Each question should have 4 options
- correctAnswer is the index (0-3) of the correct option
- Provide a brief explanation for each correct answer
- Focus on important topics from the lecture
- Make distractors (wrong answers) plausible but clearly wrong
- Adjust complexity and depth based on the ${difficulty} level

Lecture Content:
${content.substring(0, 10000)}

Respond with ONLY the JSON array, no other text.`

    // Call Gemini API with automatic retry and key rotation
    const result = await retryWithKeyRotation(
      async (apiKey: string) => {
        const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            contents: [
              {
                parts: [
                  {
                    text: prompt
                  }
                ]
              }
            ],
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: 2048
            }
          })
        })

        if (!response.ok) {
          const errorText = await response.text()
          const error: any = new Error(
            `HTTP ${response.status}: ${response.statusText}`
          )
          error.responseText = errorText
          throw error
        }

        return response.json()
      },
      {
        maxRetries: 5,
        onRetry: (attempt, error) => {
          logger.info(
            `[Quiz] Retry attempt ${attempt} due to: ${error.message}`
          )
        }
      }
    )

    if (!result.candidates || result.candidates.length === 0) {
      throw new Error('No quiz generated by Gemini API')
    }

    const generatedText = result.candidates[0].content.parts[0].text

    // Parse JSON from the response
    let questions: QuizQuestion[]
    try {
      // Extract JSON array from response (handle markdown code blocks)
      const jsonMatch = generatedText.match(/\[[\s\S]*\]/)
      if (!jsonMatch) {
        throw new Error('No JSON array found in response')
      }
      questions = JSON.parse(jsonMatch[0])
    } catch (parseError) {
      logger.error('Failed to parse quiz JSON', parseError)
      return NextResponse.json<QuizResponse>(
        {
          success: false,
          error: 'Failed to parse generated quiz',
          details: ['The AI response was not in the expected format']
        },
        { status: 500 }
      )
    }

    // Validate quiz structure
    if (!Array.isArray(questions) || questions.length === 0) {
      return NextResponse.json<QuizResponse>(
        {
          success: false,
          error: 'Invalid quiz format',
          details: ['Generated quiz was empty or malformed']
        },
        { status: 500 }
      )
    }

    return NextResponse.json<QuizResponse>(
      {
        success: true,
        quiz: {
          questions,
          totalQuestions: questions.length,
          difficulty
        }
      },
      { status: 200 }
    )
  } catch (error: any) {
    logger.error('[Quiz] Generation error after retries', error)

    // Handle retry exhaustion gracefully
    if (error.exhaustedKeys) {
      return NextResponse.json<QuizResponse>(
        {
          success: false,
          error: 'AI service temporarily unavailable',
          details: [
            'All available API keys are currently exhausted. Please try again in a few moments.'
          ]
        },
        { status: 503 }
      )
    }

    return NextResponse.json<QuizResponse>(
      {
        success: false,
        error: 'Internal server error',
        details: [error.message || 'An unexpected error occurred']
      },
      { status: 500 }
    )
  }
}
